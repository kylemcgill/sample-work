import os
import numpy as np
import scipy.stats as stats
import pandas as pd
import matplotlib.pyplot as plt
import const, categories, numericals
import math


def columnDecision(indir, outdir, df_dtypes):
    '''
    This iterates through the column files and prints out some helpful 
    stats about the column.  Then asks user whether to add it to the 
    use_col.txt file

    indir = where all the column files are located

    outdir = place to put the outfile
    '''
    outfile = 'use_col.txt'
    files = os.listdir(indir)
    
    # First need to read the 'hasDetections' file
    detections_df = pd.read_csv(indir + 'HasDetections.csv', dtype=df_dtypes)
    print(detections_df.dtypes)    
    has_detections_str = 'HasDetections'

    # Second need to iterate through all the files and append the detections to the 
    # dataframe we create with the current column.
    count = 0
    for filename in os.listdir(indir):
        print(f'Working with file: {filename}...')
        col_name = filename.split(".")[0]
        # print(col_name)
        
        current_df = pd.read_csv(indir + filename)
        current_df = pd.concat([current_df, detections_df], axis=1)
        if col_name in df_dtypes:
            # print(f'Setting {col_name} to dtype: {df_dtypes[col_name]}')
            current_df = current_df.astype({col_name : df_dtypes[col_name]}) # astype() returns the new data frame
        else:
            print(f'Column \'{col_name}\' not in \'df_dtypes\'')
            quit()
        # print(current_df[col_name])
        
        # Get some basic stats
        length_col = len(current_df[col_name])

        # Check the NaN values
        n_nan = current_df[col_name].isna().sum()
        print(f'Total number of NaN:\t{n_nan}\t{n_nan/length_col:2.2%}')

        # split into 2 groups 'hasDetections' and not
        true_df = current_df[current_df[has_detections_str] == 1]
        false_df = current_df[current_df[has_detections_str] == 0]

        print(df_dtypes[col_name])
        if df_dtypes[col_name] == 'category':
            pass
            # printCategoryStats(true_df, false_df, current_df, col_name)
        else:
            pass
            # printNumericalStats(true_df, false_df, current_df, col_name)
        # plot = createCatPlots(plot_data)

        # Ask the user whether to put col into use file
        # Put all files into file but with 1 or 0 depending
        # if we want to use it or not.
        write_mode = 'a'
        if count == 0:
            write_mode = 'w'

        with open(outdir + outfile, mode=write_mode):
            while True:
                txt = input('Use column in model [Y/n]? ')
                if (txt == 'Y') | (txt == 'yes') | (txt == 'Yes') | (txt == 'y'):
                    break
                elif(txt == 'N') | (txt == 'n') | (txt == 'no') | (txt == 'No'):
                    break
                elif (txt == 'plot') | (txt =='p'):
                    # plot.show()
                    continue
                else:
                    print('Please write \'yes\' or \'no\'!')
                    continue
        print('#'*40)
        count += 1

    print(files)


    return
# END COLUMN DECISION

def unitTestOneColumn(unit_file, df_types, arguments):
    # First need to read the 'hasDetections' file
    detections_df = pd.read_csv(arguments['in'] + 'HasDetections.csv', dtype=df_types)
    print(detections_df.dtypes)    
    has_detections_str = 'HasDetections'

    #Load the unit_file we wnat to test
    current_df = pd.read_csv(arguments['in'] + unit_file)
    col_name = unit_file.split('.')[0]
    print(f'Stripped col_name: {col_name}')
   
    # If we don't have the col_name maped then we should not process it
    # TODO: Maybe to infrencing here if we don't find it?
    if col_name not in df_types:
        print(f'{col_name} is not in the dtype map! Exiting...')
        return

    if arguments['verbose']:
        print(f'col_name dtype: {df_types[col_name]}')
    
    # Concatinate the columns to make processing easier
    current_df = pd.concat([current_df, detections_df], axis=1)

    # split into 2 groups 'hasDetections' and not
    true_df = current_df[current_df[has_detections_str] == 1]
    false_df = current_df[current_df[has_detections_str] == 0]

    # For all columns we need to check how many n/a's there are and if there 
    # is a significant difference between true and false. If there is, then we 
    # might be able to use n/a as it's own category.
    na_total = current_df[col_name].isna().sum()
    na_true = true_df[col_name].isna().sum()
    na_false = false_df[col_name].isna().sum()
    if arguments['verbose']:
        print(f'na_total: {na_total}\nna_true: {na_true}\nna_false:{na_false}')
            
    # Since we run into problems with NaN values when getting distributions, 
    # replace the NaN values with some other string which doesn't have the
    # NaN value associated with it.
    not_set_str = 'SET_NOT'
    current_df = current_df.fillna(not_set_str)
    true_df = true_df.fillna(not_set_str)
    false_df = false_df.fillna(not_set_str)

    current_dtype = df_types[col_name]
    if current_dtype == 'category':
        if arguments['pre_process']:
            # TODO: Move distributions into here for release
            pass
        if arguments['plot']:
            # TODO: Move plotting into here for release
            pass
        if arguments['interactive']:
            # TODO: Move terminal decision into here for release
            pass

        # Distribution
        categories.categoryDistribution(true_df, false_df, current_df, col_name, arguments)
        categories.chiSquareTest(true_df, false_df, current_df, col_name, arguments)
        # Plot TODO: use this example to plot the histograms
        '''
        ax = current_df.plot.hist()
        plt.show()
        '''
        # Decision
    elif (current_dtype == 'int8') | (current_dtype == 'int16') | (current_dtype == 'int32') | (current_dtype == 'int64'):
        #TODO: Call both the 'numerical' and 'categorical' preprocess
        if arguments['pre_process']:
            # TODO: Move distributions into here for release
            pass
        if arguments['plot']:
            # TODO: Move plotting into here for release
            pass
        if arguments['interactive']:
            # TODO: Move terminal decision into here for release
            pass
        
        # Distribution
        categories.categoryDistribution(true_df, false_df, current_df, col_name, arguments)
        categories.chiSquareTest(true_df, false_df, current_df, col_name, arguments)
        # Plot
        # Decision

    else:
        if arguments['pre_process']:
            # TODO: Move distributions into here for release
            pass
        if arguments['plot']:
            # TODO: Move plotting into here for release
            pass
        if arguments['interactive']:
            # TODO: Move terminal decision into here for release
            pass
        
        # Distibution
        numericals.numericalDistribution(true_df, false_df, current_df, col_name, arguments)
        # Multiple Mode?
        number_of_modes = numericals.numericalMultipleMode(true_df, false_df, current_df, col_name, arguments)
        # t-test if normal
        if number_of_modes == 1:
            numericals.tTest(true_df, false_df, current_df, col_name, arguments)
        elif number_of_modes == 0:
            print(f'There was an error in determining number of modes!')
        # Plot

    return